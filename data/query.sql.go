// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package money

import (
	"context"
	"database/sql"
)

const createAcc = `-- name: CreateAcc :one
INSERT INTO acc (
    xid, 
    name, 
    kind,
    is_active
) VALUES (
    ?, 
    ?,
    ?,
    1
) 
RETURNING id
`

type CreateAccParams struct {
	Xid  string
	Name string
	Kind string
}

func (q *Queries) CreateAcc(ctx context.Context, arg CreateAccParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createAcc, arg.Xid, arg.Name, arg.Kind)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCat = `-- name: CreateCat :exec
INSERT INTO cat (name, kind, is_active) VALUES (?, ?, 1)
`

type CreateCatParams struct {
	Name string
	Kind string
}

func (q *Queries) CreateCat(ctx context.Context, arg CreateCatParams) error {
	_, err := q.db.ExecContext(ctx, createCat, arg.Name, arg.Kind)
	return err
}

const createOrUpdateTx = `-- name: CreateOrUpdateTx :one
INSERT INTO tx (
    xid, 
    date, 
    orig_date, 
    desc, 
    orig_desc, 
    amount, 
    orig_amount, 
    acc_id,
    ord
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
) 
ON CONFLICT (xid, acc_id) DO UPDATE SET
    date = EXCLUDED.date,
    desc = EXCLUDED.desc,
    amount = EXCLUDED.amount,
    ord = EXCLUDED.ord,
    updated_at = current_timestamp
RETURNING id, created_at, updated_at
`

type CreateOrUpdateTxParams struct {
	Xid        string
	Date       string
	OrigDate   string
	Desc       string
	OrigDesc   string
	Amount     float64
	OrigAmount float64
	AccID      int64
	Ord        string
}

type CreateOrUpdateTxRow struct {
	ID        int64
	CreatedAt string
	UpdatedAt string
}

func (q *Queries) CreateOrUpdateTx(ctx context.Context, arg CreateOrUpdateTxParams) (CreateOrUpdateTxRow, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateTx,
		arg.Xid,
		arg.Date,
		arg.OrigDate,
		arg.Desc,
		arg.OrigDesc,
		arg.Amount,
		arg.OrigAmount,
		arg.AccID,
		arg.Ord,
	)
	var i CreateOrUpdateTxRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createPlan = `-- name: CreatePlan :exec
INSERT INTO plan (
    start_date, 
    end_date, 
    amount_expr, 
    cat_id,
    period
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
)
`

type CreatePlanParams struct {
	StartDate  sql.NullString
	EndDate    sql.NullString
	AmountExpr string
	CatID      int64
	Period     string
}

func (q *Queries) CreatePlan(ctx context.Context, arg CreatePlanParams) error {
	_, err := q.db.ExecContext(ctx, createPlan,
		arg.StartDate,
		arg.EndDate,
		arg.AmountExpr,
		arg.CatID,
		arg.Period,
	)
	return err
}

const createPlanPeriod = `-- name: CreatePlanPeriod :exec
INSERT INTO plan_period (
    plan_id, 
    period_start, 
    period_end, 
    amount
) VALUES (
    ?, ?, ?, ?
)
`

type CreatePlanPeriodParams struct {
	PlanID      int64
	PeriodStart string
	PeriodEnd   string
	Amount      float64
}

func (q *Queries) CreatePlanPeriod(ctx context.Context, arg CreatePlanPeriodParams) error {
	_, err := q.db.ExecContext(ctx, createPlanPeriod,
		arg.PlanID,
		arg.PeriodStart,
		arg.PeriodEnd,
		arg.Amount,
	)
	return err
}

const createRule = `-- name: CreateRule :exec
INSERT INTO rule (
    start_date, 
    end_date, 
    test_expr, 
    cat_id,
    amount_expr,
    desc_expr,
    date_expr,
    ord
) VALUES (
    ?, 
    ?, 
    ?, 
    ?, 
    ?,
    ?,
    ?,
    ?
)
`

type CreateRuleParams struct {
	StartDate  sql.NullString
	EndDate    sql.NullString
	TestExpr   string
	CatID      sql.NullInt64
	AmountExpr sql.NullString
	DescExpr   sql.NullString
	DateExpr   sql.NullString
	Ord        int64
}

func (q *Queries) CreateRule(ctx context.Context, arg CreateRuleParams) error {
	_, err := q.db.ExecContext(ctx, createRule,
		arg.StartDate,
		arg.EndDate,
		arg.TestExpr,
		arg.CatID,
		arg.AmountExpr,
		arg.DescExpr,
		arg.DateExpr,
		arg.Ord,
	)
	return err
}

const deactivateCat = `-- name: DeactivateCat :exec
UPDATE cat SET is_active = 0 WHERE id = ?
`

func (q *Queries) DeactivateCat(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deactivateCat, id)
	return err
}

const deletePlanPeriods = `-- name: DeletePlanPeriods :exec
DELETE FROM plan_period 
WHERE plan_id = ?
    AND period_start >= ?
    AND period_end < ?
`

type DeletePlanPeriodsParams struct {
	PlanID      int64
	PeriodStart string
	PeriodEnd   string
}

func (q *Queries) DeletePlanPeriods(ctx context.Context, arg DeletePlanPeriodsParams) error {
	_, err := q.db.ExecContext(ctx, deletePlanPeriods, arg.PlanID, arg.PeriodStart, arg.PeriodEnd)
	return err
}

const deleteRule = `-- name: DeleteRule :exec
DELETE FROM rule WHERE id = ?
`

func (q *Queries) DeleteRule(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteRule, id)
	return err
}

const getAccByXid = `-- name: GetAccByXid :one
SELECT id, created_at, updated_at, name, xid, kind, is_active FROM acc WHERE xid = ? LIMIT 1
`

func (q *Queries) GetAccByXid(ctx context.Context, xid string) (Acc, error) {
	row := q.db.QueryRowContext(ctx, getAccByXid, xid)
	var i Acc
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Xid,
		&i.Kind,
		&i.IsActive,
	)
	return i, err
}

const getAccs = `-- name: GetAccs :many
SELECT id, created_at, updated_at, name, xid, kind, is_active FROM acc
`

func (q *Queries) GetAccs(ctx context.Context) ([]Acc, error) {
	rows, err := q.db.QueryContext(ctx, getAccs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Acc
	for rows.Next() {
		var i Acc
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Xid,
			&i.Kind,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCats = `-- name: GetCats :many
SELECT id, created_at, updated_at, name, kind, is_active FROM cat WHERE is_active = 1 ORDER BY name
`

func (q *Queries) GetCats(ctx context.Context) ([]Cat, error) {
	rows, err := q.db.QueryContext(ctx, getCats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cat
	for rows.Next() {
		var i Cat
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Kind,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanPeriods = `-- name: GetPlanPeriods :many
SELECT plan_period.id, plan_period.created_at, plan_period.updated_at, plan_period.plan_id, plan_period.period_start, plan_period.period_end, plan_period.amount, "plan".id, "plan".created_at, "plan".updated_at, "plan".start_date, "plan".end_date, "plan".cat_id, "plan".amount_expr, "plan".period
FROM plan_period 
JOIN plan ON plan_period.plan_id = plan.id
WHERE period_start >= ? AND period_end < ?
`

type GetPlanPeriodsParams struct {
	PeriodStart string
	PeriodEnd   string
}

type GetPlanPeriodsRow struct {
	PlanPeriod PlanPeriod
	Plan       Plan
}

func (q *Queries) GetPlanPeriods(ctx context.Context, arg GetPlanPeriodsParams) ([]GetPlanPeriodsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPlanPeriods, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlanPeriodsRow
	for rows.Next() {
		var i GetPlanPeriodsRow
		if err := rows.Scan(
			&i.PlanPeriod.ID,
			&i.PlanPeriod.CreatedAt,
			&i.PlanPeriod.UpdatedAt,
			&i.PlanPeriod.PlanID,
			&i.PlanPeriod.PeriodStart,
			&i.PlanPeriod.PeriodEnd,
			&i.PlanPeriod.Amount,
			&i.Plan.ID,
			&i.Plan.CreatedAt,
			&i.Plan.UpdatedAt,
			&i.Plan.StartDate,
			&i.Plan.EndDate,
			&i.Plan.CatID,
			&i.Plan.AmountExpr,
			&i.Plan.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanPeriodsByPlan = `-- name: GetPlanPeriodsByPlan :many
SELECT id, created_at, updated_at, plan_id, period_start, period_end, amount 
FROM plan_period 
WHERE plan_id = ? 
    AND period_start >= ? 
    AND period_end < ?
`

type GetPlanPeriodsByPlanParams struct {
	PlanID      int64
	PeriodStart string
	PeriodEnd   string
}

func (q *Queries) GetPlanPeriodsByPlan(ctx context.Context, arg GetPlanPeriodsByPlanParams) ([]PlanPeriod, error) {
	rows, err := q.db.QueryContext(ctx, getPlanPeriodsByPlan, arg.PlanID, arg.PeriodStart, arg.PeriodEnd)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlanPeriod
	for rows.Next() {
		var i PlanPeriod
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanID,
			&i.PeriodStart,
			&i.PeriodEnd,
			&i.Amount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlans = `-- name: GetPlans :many
SELECT id, created_at, updated_at, start_date, end_date, cat_id, amount_expr, period 
FROM plan 
WHERE (start_date IS NULL OR start_date >= ?) 
    AND (end_date IS NULL OR end_date < ?)
ORDER BY start_date DESC
`

type GetPlansParams struct {
	StartDate sql.NullString
	EndDate   sql.NullString
}

func (q *Queries) GetPlans(ctx context.Context, arg GetPlansParams) ([]Plan, error) {
	rows, err := q.db.QueryContext(ctx, getPlans, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Plan
	for rows.Next() {
		var i Plan
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartDate,
			&i.EndDate,
			&i.CatID,
			&i.AmountExpr,
			&i.Period,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRules = `-- name: GetRules :many
SELECT id, created_at, updated_at, start_date, end_date, test_expr, cat_id, amount_expr, desc_expr, date_expr, ord FROM rule 
WHERE (start_date IS NULL OR start_date >= ?) 
    AND (end_date IS NULL OR end_date < ?)
ORDER BY ord
`

type GetRulesParams struct {
	StartDate sql.NullString
	EndDate   sql.NullString
}

func (q *Queries) GetRules(ctx context.Context, arg GetRulesParams) ([]Rule, error) {
	rows, err := q.db.QueryContext(ctx, getRules, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Rule
	for rows.Next() {
		var i Rule
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StartDate,
			&i.EndDate,
			&i.TestExpr,
			&i.CatID,
			&i.AmountExpr,
			&i.DescExpr,
			&i.DateExpr,
			&i.Ord,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTxByAccAndXid = `-- name: GetTxByAccAndXid :one
SELECT id, created_at, updated_at, xid, date, orig_date, "desc", orig_desc, amount, orig_amount, acc_id, ord FROM tx WHERE acc_id = ? AND xid = ? LIMIT 1
`

type GetTxByAccAndXidParams struct {
	AccID int64
	Xid   string
}

func (q *Queries) GetTxByAccAndXid(ctx context.Context, arg GetTxByAccAndXidParams) (Tx, error) {
	row := q.db.QueryRowContext(ctx, getTxByAccAndXid, arg.AccID, arg.Xid)
	var i Tx
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Xid,
		&i.Date,
		&i.OrigDate,
		&i.Desc,
		&i.OrigDesc,
		&i.Amount,
		&i.OrigAmount,
		&i.AccID,
		&i.Ord,
	)
	return i, err
}

const getTxs = `-- name: GetTxs :many
SELECT tx.id, tx.created_at, tx.updated_at, tx.xid, tx.date, tx.orig_date, tx."desc", tx.orig_desc, tx.amount, tx.orig_amount, tx.acc_id, tx.ord, acc.id, acc.created_at, acc.updated_at, acc.name, acc.xid, acc.kind, acc.is_active, cat.id, cat.created_at, cat.updated_at, cat.name, cat.kind, cat.is_active
FROM tx
JOIN acc ON tx.acc_id = acc.id
LEFT JOIN tx_cat ON tx.id = tx_cat.tx_id
LEFT JOIN cat ON tx_cat.cat_id = cat.id
WHERE ord < ?
ORDER BY ord DESC
LIMIT ?
`

type GetTxsParams struct {
	Ord   string
	Limit int64
}

type GetTxsRow struct {
	Tx  Tx
	Acc Acc
	Cat Cat
}

func (q *Queries) GetTxs(ctx context.Context, arg GetTxsParams) ([]GetTxsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTxs, arg.Ord, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTxsRow
	for rows.Next() {
		var i GetTxsRow
		if err := rows.Scan(
			&i.Tx.ID,
			&i.Tx.CreatedAt,
			&i.Tx.UpdatedAt,
			&i.Tx.Xid,
			&i.Tx.Date,
			&i.Tx.OrigDate,
			&i.Tx.Desc,
			&i.Tx.OrigDesc,
			&i.Tx.Amount,
			&i.Tx.OrigAmount,
			&i.Tx.AccID,
			&i.Tx.Ord,
			&i.Acc.ID,
			&i.Acc.CreatedAt,
			&i.Acc.UpdatedAt,
			&i.Acc.Name,
			&i.Acc.Xid,
			&i.Acc.Kind,
			&i.Acc.IsActive,
			&i.Cat.ID,
			&i.Cat.CreatedAt,
			&i.Cat.UpdatedAt,
			&i.Cat.Name,
			&i.Cat.Kind,
			&i.Cat.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCat = `-- name: UpdateCat :exec
UPDATE cat SET name = ? WHERE id = ?
`

type UpdateCatParams struct {
	Name string
	ID   int64
}

func (q *Queries) UpdateCat(ctx context.Context, arg UpdateCatParams) error {
	_, err := q.db.ExecContext(ctx, updateCat, arg.Name, arg.ID)
	return err
}

const updatePlan = `-- name: UpdatePlan :exec
UPDATE plan SET start_date = ?, end_date = ?, amount_expr = ? WHERE id = ?
`

type UpdatePlanParams struct {
	StartDate  sql.NullString
	EndDate    sql.NullString
	AmountExpr string
	ID         int64
}

func (q *Queries) UpdatePlan(ctx context.Context, arg UpdatePlanParams) error {
	_, err := q.db.ExecContext(ctx, updatePlan,
		arg.StartDate,
		arg.EndDate,
		arg.AmountExpr,
		arg.ID,
	)
	return err
}

const updatePlanPeriod = `-- name: UpdatePlanPeriod :exec
UPDATE plan_period SET amount = ? WHERE id = ?
`

type UpdatePlanPeriodParams struct {
	Amount float64
	ID     int64
}

func (q *Queries) UpdatePlanPeriod(ctx context.Context, arg UpdatePlanPeriodParams) error {
	_, err := q.db.ExecContext(ctx, updatePlanPeriod, arg.Amount, arg.ID)
	return err
}

const updateRule = `-- name: UpdateRule :exec
UPDATE rule SET 
    start_date = ?,
    end_date = ?,
    test_expr = ?,
    cat_id = ?,
    amount_expr = ?,
    desc_expr = ?,
    date_expr = ?,
    ord = ?
WHERE id = ?
`

type UpdateRuleParams struct {
	StartDate  sql.NullString
	EndDate    sql.NullString
	TestExpr   string
	CatID      sql.NullInt64
	AmountExpr sql.NullString
	DescExpr   sql.NullString
	DateExpr   sql.NullString
	Ord        int64
	ID         int64
}

func (q *Queries) UpdateRule(ctx context.Context, arg UpdateRuleParams) error {
	_, err := q.db.ExecContext(ctx, updateRule,
		arg.StartDate,
		arg.EndDate,
		arg.TestExpr,
		arg.CatID,
		arg.AmountExpr,
		arg.DescExpr,
		arg.DateExpr,
		arg.Ord,
		arg.ID,
	)
	return err
}

const updateTx = `-- name: UpdateTx :exec
UPDATE tx SET
    date = ?,
    desc = ?,
    amount = ?,
    ord = ?
WHERE id = ?
`

type UpdateTxParams struct {
	Date   string
	Desc   string
	Amount float64
	Ord    string
	ID     int64
}

func (q *Queries) UpdateTx(ctx context.Context, arg UpdateTxParams) error {
	_, err := q.db.ExecContext(ctx, updateTx,
		arg.Date,
		arg.Desc,
		arg.Amount,
		arg.Ord,
		arg.ID,
	)
	return err
}
